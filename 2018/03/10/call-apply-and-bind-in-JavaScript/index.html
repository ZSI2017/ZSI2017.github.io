<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>call,apply and bind in JavaScript | blog</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://yoursite.com/2018/03/10/call-apply-and-bind-in-JavaScript/"/>
<meta name="description" content="call,apply and bind in JavaScript 在ECMAScript中，每个函数都包含两个继承而来的方法：apply() 和…">
<meta name="keywords" content="OriginJS">
<meta property="og:type" content="article">
<meta property="og:title" content="call,apply and bind in JavaScript">
<meta property="og:url" content="http://yoursite.com/2018/03/10/call-apply-and-bind-in-JavaScript/">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="call,apply and bind in JavaScript 在ECMAScript中，每个函数都包含两个继承而来的方法：apply() 和…">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://yoursite.com/images/apply.jpg">
<meta property="og:updated_time" content="2018-03-10T13:53:49.353Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="call,apply and bind in JavaScript">
<meta name="twitter:description" content="call,apply and bind in JavaScript 在ECMAScript中，每个函数都包含两个继承而来的方法：apply() 和…">
<meta name="twitter:image" content="http://yoursite.com/images/apply.jpg"><meta property="article:author" content="lq"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-03-10 21:47:24"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="lq"><link rel="icon" href="/images/logo.png"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/logo.png" alt="blog"><span class="menu__item__link--brand__label">blog</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">call,apply and bind in JavaScript</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-03-10T13:47:24.000Z" itemprop="datePublished">2018-03-10 21:47:24</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/OriginJS/">OriginJS</a></div></div><div class="article__contents"><img src="/images/apply.jpg"/><h2 id="call-apply-and-bind-in-JavaScript"><a href="#call-apply-and-bind-in-JavaScript" class="headerlink" title="call,apply and bind in JavaScript"></a>call,apply and bind in JavaScript</h2><blockquote>
<p>在ECMAScript中，每个函数都包含两个继承而来的方法：apply() 和 call(),这两个方法的用途都是在特定的作用域中调用函数，主要作用跟bind一样，用来改变函数体内this的指向，或者说是在函数调用时改变上下文。</p>
</blockquote>
<p><strong>文章尽量使用大量实例进行讲解，它们的使用场景。同时，也会由浅入深的引导出一些理论，毕竟这几个常用方法，在MDN上都能找到合理的解释</strong></p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="改变this的指向"><a href="#改变this的指向" class="headerlink" title="改变this的指向"></a>改变this的指向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var fruit = &#123;</span><br><span class="line">  fruitName:&quot;apple&quot;</span><br><span class="line">&#125;</span><br><span class="line">function getFruit() &#123;</span><br><span class="line">  console.log(&quot;I like &quot;+this.fruitName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFruit();    // log   I like undefined</span><br><span class="line">getFruit.call(fruit)    // log   I like apple</span><br><span class="line">getFruit.apply(fruit)   // log   I like apple</span><br><span class="line">var newBind = getFruit.bind(fruit)</span><br><span class="line">newBind();              // log   I like apple</span><br></pre></td></tr></table></figure>
<p>当 getFruit 并非作为一个对象的属性，而是直接当做一个函数来调用,里面的<code>this</code>就会被绑定到全局对象上，即window上， 所以直接调用 <code>getFruit</code>,里面的<code>this</code>指向了全局对象上，返回 <code>undefined</code>。</p>
<blockquote>
<p>在严格模式下，函数被调用后，里面的this默认是 undefined</p>
</blockquote>
<p>后面,通过调用函数上的<code>call</code>和<code>apply</code>方法，该变<code>this</code>指向，函数里面的<code>this</code>指向<code>fruit</code>。</p>
<p>区别：<br><code>bind</code>同样实现了改变<code>this</code>指向的功能，但是它不会立即执行，而是会重新创建一个绑定函数，新函数被调用时，使用<code>bind()</code>方法里面的第一个参数作为<code>this</code></p>
<h3 id="接受参数"><a href="#接受参数" class="headerlink" title="接受参数"></a>接受参数</h3><p> 这三个方法，从接受的第二参数开始，都直接传递给函数，但是接受参数的方法却很大的不同。</p>
<p> <strong>call</strong>，从第二个参数开始，以参数列表的形式展示，</p>
<p> <strong>apply</strong>，则把传递的函数参数，放在一个数组里面作为第二个参数。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.call(obj,arg1,arg2);</span><br><span class="line">fn.apply(obj,[arg1,arg2])</span><br></pre></td></tr></table></figure>
<p> <strong>bind</strong>，从第二个参数开始，同样以参数列表的形式，但是会提前放在新绑定函数的参数之前<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo = function(name,age)&#123;</span><br><span class="line">  console.log(&quot;name: &quot;+name+&quot;- age: &quot;+age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = foo.bind(this,&quot;popo&quot;);   // &quot;popo&quot; 作为新函数的第一个参数。</span><br><span class="line">p1(13);                       // logs    name: popo- age: 13</span><br><span class="line">p1(&quot;bobo&quot;,14)                 // logs    name: popo- age: bobo</span><br></pre></td></tr></table></figure></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>绑定事件回调中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;.div-class&apos;).on(&apos;click&apos;,function(event) &#123;</span><br><span class="line">      /*TODO*/</span><br><span class="line">      &#125;.bind(this));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通常，我们在改变函数上下文之前，都会使用类似<code>that = this</code>,或者<code>self,_this</code>，来把this赋值给一个变量。利用<code>.bind()</code>，可以传入外层的上下文。</p>
<ul>
<li>实现继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var Person = function(name,age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var P1 = function(name,age) &#123;</span><br><span class="line">  // 借用构造函数的方式实现继承</span><br><span class="line">  // 利用call 继承了Person</span><br><span class="line">  Person.call(this,name,age)</span><br><span class="line">&#125;</span><br><span class="line">P1.prototype.getName = function() &#123;</span><br><span class="line">  console.log(&quot;name: &quot;+this.name+&quot;, age: &quot;+this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newPerson = new P1(&quot;popo&quot;,20);   // logs name: popo, age: 20</span><br><span class="line">newPerson.getName();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>实质上，可以看成通过<code>call()</code>或者<code>apply()</code>方法，在即将新建的对象，即这里的<code>newPerson</code>上，执行超类型的构造函数，分别在当前上下文<code>this</code>上添加<code>name</code>和<code>age</code>属性。</p>
<ul>
<li>数组验证的终极方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isArray(value) &#123;</span><br><span class="line">  return Object.prototype.toString.call(value) == &quot;[object Array]&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>借用了Object原生的toString()方法，打印出对应变量的构造函数名，</p>
<ul>
<li><p>类数组转换为数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 实现一个简单的数组 &apos;unshift&apos;方法</span><br><span class="line">Array.prototype.unshift = function()&#123;</span><br><span class="line">  this.splice.apply(this,</span><br><span class="line">    [0,0].concat(Array.prototype.slice.apply(arguments)));</span><br><span class="line">    return this.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，利用<code>this.splice.apply()</code>,其中<code>splice</code>，可以直接从数组中移除或者插入变量。<code>apply()</code>则以数组的形式传递参数，需要利用<code>concat</code>拼接数组。</p>
<p>当函数被调用时，在函数内部会得到类数组<code>arguments</code>，它拥有一个length属性，但是没有任何数组的方法。所以，将<code>slice</code>方法中的<code>this</code>指向<code>arguments</code>，获取到<code>arguments</code>的长度，从而确定方法的<code>start</code>和<code>end</code>下标，得到一个数组变量。</p>
<p>同样适用的还有，DOM里面的NodeList对象，它也是一种类数组对象。</p>
</li>
</ul>
<h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="实现bind-方法"><a href="#实现bind-方法" class="headerlink" title="实现bind 方法"></a>实现bind 方法</h3><p>   <code>bind</code>方法在ECMAScript5里面被引入，前面提到过，调用该方法时，返回一个新的函数，可以简单使用下面方法实现其改变<code>this</code>指向的功能。<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(scope) &#123;</span><br><span class="line">  var fn = this;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    return fn.apply(scope)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 接着，就可以利用<code>concat</code>把bind传递的预置参数拼接到新函数的参数列表中。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(scope) &#123;</span><br><span class="line">   var args = Array.prototype.slice.call(arguments,1)</span><br><span class="line">   var fn = this</span><br><span class="line">   return function() &#123;</span><br><span class="line">     return fn.apply(scope,args.concat(Array.prototype.slice.call(arguments)))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <strong>参考链接</strong></p>
<ul>
<li><a href="https://github.com/Aaaaaaaty/Blog/issues/1" target="_blank" rel="noopener">Javascript之bind</a></li>
<li><a href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/" target="_blank" rel="noopener">Understanding JavaScript Bind ()</a></li>
<li><a href="https://mp.weixin.qq.com/s/BYbCgTMt7nvChPddWor0Tw" target="_blank" rel="noopener">深入浅出妙用 Javascript 中 apply、call、bind</a></li>
<li><a href="https://juejin.im/entry/58a3605e570c35005786f9bf/" target="_blank" rel="noopener">前端基础进阶：全方位解读 this</a></li>
</ul>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/OriginJS/">OriginJS</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/avatar.jpg" alt="lq"><a class="article__author__link" title="About lq" rel="author">lq</a><p class="article__author__desc">博客</p><div class="article__author__socials"><a class="article__author__socials__item" href="https://github.com/ZSI2017" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="https://segmentfault.com/u/bukenengdeshi" title="segmentfault" target="_blank"><i class="fa fa-segmentfault"></i></a></div><meta itemprop="name" content="lq"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-03-10T13:53:49.353Z"><meta itemprop="articleBody" content="call,apply and bind in JavaScript
在ECMAScript中，每个函数都包含两个继承而来的方法：apply() 和..."><meta itemprop="url" content="http://yoursite.com/2018/03/10/call-apply-and-bind-in-JavaScript/"><meta itemprop="mainEntityOfPage" content="http://yoursite.com/2018/03/10/call-apply-and-bind-in-JavaScript/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="blog"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://yoursite.com/images/logo.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://yoursite.com/images/apply.jpg"><meta itemprop="url" content="http://yoursite.com/images/apply.jpg"><meta itemprop="width" content="128"><meta itemprop="height" content="128"></div></article></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2018/03/10/call-apply-and-bind-in-JavaScript/">call,apply and bind in JavaScript</a></li><li class="recent-posts__item"><a href="/2018/03/08/《JavaScript语言精粹》读书笔记-函数（二）/">《JavaScript语言精粹》读书笔记-函数（二）</a></li><li class="recent-posts__item"><a href="/2018/02/27/《JavaScript语言精粹》读书笔记-函数/">《JavaScript语言精粹》读书笔记- 函数</a></li><li class="recent-posts__item"><a href="/2018/01/02/Vue2-0组件间事件派发机制/">Vue2.0组件间事件派发机制</a></li><li class="recent-posts__item"><a href="/2017/12/16/前端代码规范/">前端代码规范</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">5</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/OriginJS/">OriginJS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/originJS/">originJS</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/《JavaScript语言精粹》读书笔记/">《JavaScript语言精粹》读书笔记</a><span class="category-list-count">2</span></li></ul></div></div></div><p class="copyright"><small>© 2018 lq<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>