<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Vue2.0组件间事件派发机制 | blog</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://yoursite.com/2018/01/02/Vue2-0组件间事件派发机制/"/>
<meta name="description" content="vue2.0…">
<meta name="keywords" content="Vue">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue2.0组件间事件派发机制">
<meta property="og:url" content="http://yoursite.com/2018/01/02/Vue2-0组件间事件派发机制/">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="vue2.0…">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://yoursite.com/images/sync.png">
<meta property="og:updated_time" content="2018-02-21T07:45:22.844Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue2.0组件间事件派发机制">
<meta name="twitter:description" content="vue2.0…">
<meta name="twitter:image" content="http://yoursite.com/images/sync.png"><meta property="article:author" content="lq"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-01-02 00:00:00"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="lq"><link rel="icon" href="/images/logo.png"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/logo.png" alt="blog"><span class="menu__item__link--brand__label">blog</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">Vue2.0组件间事件派发机制</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-01-01T16:00:00.000Z" itemprop="datePublished">2018-01-02 00:00:00</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/Vue/">Vue</a></div></div><div class="article__contents"><img src="/images/sync.png"/><h2 id="vue2-0-父子组件间事件派发机制"><a href="#vue2-0-父子组件间事件派发机制" class="headerlink" title="vue2.0 父子组件间事件派发机制"></a>vue2.0 父子组件间事件派发机制</h2><p>从vue1.x过来的都知道，在vue2.0中，父子组件间事件通信的<code>$dispatch</code>和<code>$broadcase</code>被移除了。官方考虑是<strong>基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆落</strong>。特别是在组件层级比较深的情况下。通过广播和事件分发的机制，就显得比较混乱了。</p>
<p>  <strong>官方在废除的同时，也为我们提供了替换方案，包括实例化一个空的vue实例，使用<a href="https://cn.vuejs.org/v2/guide/migration.html?#dispatch-和-broadcast-替换" target="_blank" rel="noopener">$emit反应子组件上的状态变化</a></strong></p>
<h2 id="1-使用-emit触发事件"><a href="#1-使用-emit触发事件" class="headerlink" title="1.使用$emit触发事件"></a>1.使用$emit触发事件</h2><p>  <code>helloWorld.vue</code>作为父组件，<code>dialogConfigVisible</code>变量控制子组件弹框显示或隐藏。<br>  <code>configBox.vue</code>作为子组件，假设为封装的公告弹窗。</p>
<p>   在父组件中 helloWorld.vue 中</p>
<p><strong>&lt; template/&gt;</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;config-box</span><br><span class="line">   :visible=&quot;dialogConfigVisible&quot;                </span><br><span class="line">    @listenToConfig=&quot;changeConfigVisible&quot;</span><br><span class="line">&gt; &lt;/config-box&gt;</span><br></pre></td></tr></table></figure>
<p> <strong>script</strong><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    dialogConfigVisible:true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> methods: &#123;</span><br><span class="line">   changeConfigVisible(flag) &#123;</span><br><span class="line">       this.dialogConfigVisible = flag;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，在子组件 configBox.vue 中，主要在任意事件回调中,使用 <code>$emit</code>来触发自定义的 <code>listenToConfig</code>事件，后面还可以加上参数传给父组件。比如，在子组件弹窗上点击×关闭时，通知父组件 <code>helloWorld.vue</code>我要关闭了，主要方便父组件改变相应状态变量，并传入false到自定义的事件中。</p>
<p><strong>script</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  dialogClose() &#123;</span><br><span class="line">    this.show = false;</span><br><span class="line">    this.$emit(&quot;listenToConfig&quot;, false)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 在子組件中，主动触发<code>listenToConfig</code>事件，并传入参数 false, 告诉父组件 <code>helloWorld.vue</code>对话框要关闭了。这里就可以避免父组件中的状态未变化，再次刷新页面的时候对话框会自动出现。</p>
<h2 id="2-实例化一个空的vue实例bus"><a href="#2-实例化一个空的vue实例bus" class="headerlink" title="2.实例化一个空的vue实例bus"></a>2.实例化一个空的vue实例bus</h2><p><strong>这里实例化一个bus 空vue实例，主要为了统一管理子组件和父组件相互通信，通过bus 作为媒介，</strong><br>首先新建一个bus.js 文件，在里面新建一个对象，父组件为<code>table.vue</code>， 子组件为<code>tableColumn.vue</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> // bus.js</span><br><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">export var bus = new Vue(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">      scrollY:false</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">       updateScrollY(flag)&#123;</span><br><span class="line">         this.scrollY = flag;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>然后分别引入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// table.vue</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> import &#123;bus&#125;  from &quot;./bus&quot;</span><br><span class="line">  export default &#123;</span><br><span class="line">     created()&#123;</span><br><span class="line">       bus.$on(&apos;getData&apos;,(argsData)=&gt;&#123;</span><br><span class="line">         // 这里获取子组件传来的参数</span><br><span class="line">         console.log(argsData);</span><br><span class="line">         &#125;)</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &lt;/script&gt;</span><br><span class="line"></span><br><span class="line"> // tableColumn.vue</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   import &#123;bus&#125; from &quot;./bus&quot;</span><br><span class="line">   export default&#123;</span><br><span class="line">     methods()&#123;</span><br><span class="line">       handleClick()&#123;</span><br><span class="line">         bus.$emit(&apos;getData&apos;,&#123;data:&quot;from tableColumn!&quot;&#125;)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>  上面的父子组件中，父组件中利用<code>bus</code>注册监听事件<code>getData</code>,子组件中一旦有状态变化，就触发<code>bus</code>上对应的事件。</p>
<p>  <strong>这种利用空实例的方式，相当于创建了一个事件中心，所以这种通信同样适用于非父子组件间的通信，</strong></p>
<h2 id="3-多级父子组件通信"><a href="#3-多级父子组件通信" class="headerlink" title="3.多级父子组件通信"></a>3.多级父子组件通信</h2><p>   <strong>有时，可能想要实现通信的两个组件不是直接的父子组件，而是祖父和孙子，或者是跨越了更多层级的父子组件</strong></p>
<p>   不可能由子组件一级一级的向上传递参数，来达到通信的目的，虽然现在我们理解的通信都是这样经过中转的。可以通过<code>while</code>等循环，不断向上遍历，直到找到目标父组件，就在对应的组件上触发事件。</p>
<p>   下面就只<code>element-ui</code>实现的一个<a href="https://github.com/ElemeFE/element/blob/dev/src/mixins/emitter.js" target="_blank" rel="noopener">父子组件通信的<code>mixins</code></a>,对于组件同步有很大的作用。在<a href="https://mp.weixin.qq.com/s/vD0E5YzBtk9w7ZeddtXy1Q" target="_blank" rel="noopener">element-ui 的优点概述</a>中也特意提到这个组件通信<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function broadcast(componentName, eventName, params) &#123;</span><br><span class="line"></span><br><span class="line">  // 向下遍历每个子节点，触发相应的向下广播的 事件</span><br><span class="line">  this.$children.forEach(child =&gt; &#123;</span><br><span class="line">    var name = child.$options.componentName;</span><br><span class="line"></span><br><span class="line">    if (name === componentName) &#123;</span><br><span class="line">      child.$emit.apply(child, [eventName].concat(params));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      broadcast.apply(child, [componentName, eventName].concat([params]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">     // 向上遍历父节点，来获取指定父节点，通过$emit 在相应的 组件中触发 eventName  事件</span><br><span class="line">    dispatch(componentName, eventName, params) &#123;</span><br><span class="line">      var parent = this.$parent || this.$root;</span><br><span class="line">      var name = parent.$options.componentName;</span><br><span class="line">      // 上面的componentName 需要在每个vue 实例中额外配置自定义属性 componentName,</span><br><span class="line">      //可以简单替换成var name = parent.$options._componentTag;</span><br><span class="line"></span><br><span class="line">      while (parent &amp;&amp; (!name || name !== componentName)) &#123;</span><br><span class="line">        parent = parent.$parent;</span><br><span class="line"></span><br><span class="line">        if (parent) &#123;</span><br><span class="line">          name = parent.$options.componentName;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (parent) &#123;</span><br><span class="line">        parent.$emit.apply(parent, [eventName].concat(params));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    broadcast(componentName, eventName, params) &#123;</span><br><span class="line">      broadcast.call(this, componentName, eventName, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>  <strong>首先定义两个嵌套的组件 f1.vue 和 c1.vue</strong>,实例是：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;f1&gt;</span><br><span class="line">  &lt;c1&gt;&lt;/c1&gt;</span><br><span class="line">&lt;/f1&gt;</span><br></pre></td></tr></table></figure></p>
<p>  然后，分别定义两个父子组件：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  c2.vue</span><br><span class="line"></span><br><span class="line">   &lt;template&gt;</span><br><span class="line">       &lt;section&gt;</span><br><span class="line">       &lt;button type=&quot;button&quot; name=&quot;button&quot; @click=&quot;dispatchTest&quot;&gt;点击一下，就可以&lt;/button&gt;</span><br><span class="line">     &lt;/section&gt;</span><br><span class="line">   &lt;/template&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">import Emitter from &quot;../mixins/emitter&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;c2&quot;,</span><br><span class="line">  mixins: [Emitter],</span><br><span class="line">  componentName:&apos;c2&apos;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    dispatchTest() &#123;</span><br><span class="line">      this.dispatch(&apos;f1&apos;, &apos;listenerToC1&apos;, false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   f1.vue</span><br><span class="line"></span><br><span class="line">  &lt;template type=&quot;html&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;outBox-class&quot;&gt;</span><br><span class="line">      &lt;slot&gt;</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">import Emitter from &quot;../mixins/emitter&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;f1&quot;,</span><br><span class="line">  mixins: [Emitter],</span><br><span class="line">  componentName: &apos;f1&apos;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.$on(&quot;listenerToC1&quot;, (value) =&gt; &#123;</span><br><span class="line">       alert(value);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这样，就可以在子组件中点击按钮，触发 <code>listenerToC1</code>事件，在父组件中监听到这个事件，<br>其实更<code>$emit</code>触发事件类似。不同之处在于，这里可以多级嵌套，不一定是直接的父子组件都可以触发到。</p>
<h2 id="4-sync-修饰符"><a href="#4-sync-修饰符" class="headerlink" title="4 .sync 修饰符"></a>4 .sync 修饰符</h2><p>  在Vue1.x中，利用prop进行”双向绑定”,实现父子组件通信，都会用到<code>.sync</code>修饰符，可以将子组件中对应的prop值变化同步到父组件中。但是，这样就破坏了单向数据流，在2.0版本中被移除了，在2.3.0版本中又以一种语法糖的形式加了进来。<br>可以看下<a href="https://cn.vuejs.org/v2/guide/components.html#sync-修饰符" target="_blank" rel="noopener">文档上给出的实例</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;comp :foo.sync=“bar”&gt;&lt;/comp&gt;</span><br></pre></td></tr></table></figure>
<p>被扩展为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;comp :foo=&quot;bar&quot; @update:foo= &quot;val =&gt;bar=val&quot;&gt;&lt;/comp&gt;</span><br></pre></td></tr></table></figure></p>
<p>其实跟本文中第一种方法基本一致，更加简化了。</p>
<p>同样<code>helloWorld.vue</code>作为父组件， <code>configBox.vue</code>作为子组件，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   &lt;config-box</span><br><span class="line">   :visible.sync=&quot;dialogConfigVisible&quot;                </span><br><span class="line">&gt; &lt;/config-box&gt;</span><br></pre></td></tr></table></figure>
<p>然后在子组件中，显式的触发更新事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  dialogClose() &#123;</span><br><span class="line">    this.show = false;</span><br><span class="line">    this.$emit(&quot;update:visible&quot;, false)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样visible 的变化就能同步到父组件中了。</p>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/Vue/">Vue</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/avatar.jpg" alt="lq"><a class="article__author__link" title="About lq" rel="author">lq</a><p class="article__author__desc">博客</p><div class="article__author__socials"><a class="article__author__socials__item" href="https://github.com/ZSI2017" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="https://segmentfault.com/u/bukenengdeshi" title="segmentfault" target="_blank"><i class="fa fa-segmentfault"></i></a></div><meta itemprop="name" content="lq"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-02-21T07:45:22.844Z"><meta itemprop="articleBody" content="vue2.0 父子组件间事件派发机制从vue1.x过来的都知道，在vue2.0中，父子组件间事件通信的$dispatch和$broadcase被移除了。官方考虑是基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆落。特别是在组件层级比较深的情况下。通过广播和事件分发的机制，就显得比较混乱了。
 ..."><meta itemprop="url" content="http://yoursite.com/2018/01/02/Vue2-0组件间事件派发机制/"><meta itemprop="mainEntityOfPage" content="http://yoursite.com/2018/01/02/Vue2-0组件间事件派发机制/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="blog"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://yoursite.com/images/logo.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://yoursite.com/images/sync.png"><meta itemprop="url" content="http://yoursite.com/images/sync.png"><meta itemprop="width" content="1280"><meta itemprop="height" content="128"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2017/08/13/v-model-详解/"><div class="related-posts__item__background" style="background-image:url('/images/vModel.jpg');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">v-model 详解</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2017/08/13/Mixin-vue/"><div class="related-posts__item__background" style="background-image:url('/images/mixin.jpg');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Mixin - vue</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2018/03/10/call-apply-and-bind-in-JavaScript/">call,apply and bind in JavaScript</a></li><li class="recent-posts__item"><a href="/2018/03/08/《JavaScript语言精粹》读书笔记-函数（二）/">《JavaScript语言精粹》读书笔记-函数（二）</a></li><li class="recent-posts__item"><a href="/2018/02/27/《JavaScript语言精粹》读书笔记-函数/">《JavaScript语言精粹》读书笔记- 函数</a></li><li class="recent-posts__item"><a href="/2018/01/02/Vue2-0组件间事件派发机制/">Vue2.0组件间事件派发机制</a></li><li class="recent-posts__item"><a href="/2017/12/16/前端代码规范/">前端代码规范</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">5</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/OriginJS/">OriginJS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/originJS/">originJS</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/《JavaScript语言精粹》读书笔记/">《JavaScript语言精粹》读书笔记</a><span class="category-list-count">2</span></li></ul></div></div></div><p class="copyright"><small>© 2018 lq<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>